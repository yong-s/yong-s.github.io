<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yong-s.github.io</id>
    <title>Yongs的网络日志</title>
    <updated>2021-06-06T11:13:09.997Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yong-s.github.io"/>
    <link rel="self" href="https://yong-s.github.io/atom.xml"/>
    <subtitle>手艺人、搞钱、剪片子、生活......</subtitle>
    <logo>https://yong-s.github.io/images/avatar.png</logo>
    <icon>https://yong-s.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Yongs的网络日志</rights>
    <entry>
        <title type="html"><![CDATA[girde simple修改添加支持侧边栏目录]]></title>
        <id>https://yong-s.github.io/post/girde-simple-xiu-gai-tian-jia-zhi-chi-ce-bian-lan-mu-lu/</id>
        <link href="https://yong-s.github.io/post/girde-simple-xiu-gai-tian-jia-zhi-chi-ce-bian-lan-mu-lu/">
        </link>
        <updated>2021-06-06T10:50:26.000Z</updated>
        <summary type="html"><![CDATA[<p>修改主题文件支持侧边栏目录</p>
]]></summary>
        <content type="html"><![CDATA[<p>修改主题文件支持侧边栏目录</p>
<!-- more -->
<p>simple主题整体还行，但文章无侧边栏目录，一般写的技术性文章很长，就需要侧边栏目录和这个功能了，在网上搜了一下资料，对于前端小学生的我费了好长时间才搞定，记录一下过程。</p>
<h3 id="1-修改postejs文件">1、修改post.ejs文件</h3>
<p><code>head</code>新增</p>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<p>搜索<code>&lt;%- post.content %&gt;</code>复制一下代码覆盖copy</p>
<pre><code class="language-html">&lt;div class=&quot;post-content-wrapper&quot;&gt;
  &lt;div class=&quot;post-content&quot; v-pre&gt;
    &lt;%- post.content %&gt;
  &lt;/div&gt;
  &lt;div class=&quot;toc-container&quot;&gt;
   &lt;%- post.toc %&gt;
 &lt;/div&gt;
</code></pre>
<p>新增高亮js</p>
<pre><code class="language-javascript">&lt;script&gt;
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(&quot;.markdownIt-TOC a&quot;);

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener(&quot;scroll&quot;, () =&gt; {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener(&quot;scroll&quot;, event =&gt; {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) =&gt; {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop &lt;= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop &gt; fromTop) {
                link.classList.add(&quot;current&quot;);
              } else {
                link.classList.remove(&quot;current&quot;);    
              }
            } else {
              link.classList.add(&quot;current&quot;);
            }
          } else {
            link.classList.remove(&quot;current&quot;);
          }
        });
      });

    &lt;/script&gt;
</code></pre>
<h3 id="2-客户端新增自定义css">2、客户端新增自定义css</h3>
<pre><code class="language-css">.toc-container  .markdownIt-TOC {
    position: sticky;
    top: 32px;
    width: 200px;
    font-size: 12px;
    list-style: none;
    padding-left: 0;
    padding: 16px 8px;
 }
.toc-container  .markdownIt-TOC:before {
      content: &quot;&quot;;
      position: absolute;
      top: 0;
      left: 8px;
      bottom: 0;
      width: 1px;
      background-color: #ebedef;
      opacity: .5;
  }
.toc-container  ul {
    list-style: none;
  }
.toc-container  li {
    padding-left: 16px;
}
.toc-container  li a {
      color: #868e96;
      padding: 4px;
      display: block;
      transition: all 0.3s;
  }
.toc-container  li a:hover {
        background: #cddbef;
      }
.toc-container  li a.current {
        color: #006CFF;
        background: #fafafa;
  }
.post-content-wrapper {
display: flex;
}
.post-content {
width: 100%;
margin-right: 20px;
}
@media (max-width: 1150px) {
  .toc-container {
    display: none;
  }
}
</code></pre>
<h3 id="3-修改maincss文件">3、修改main.css文件</h3>
<p>搜索<code>.post-detail</code> 修改<code>margin: 0 auto;</code>为</p>
<p><code>margin: 0 20px;</code></p>
<p>重新渲染网页即可尽情享用吧！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[云服务器docker搭建自动领京豆bot互动指令]]></title>
        <id>https://yong-s.github.io/post/yun-fu-wu-qi-docker-da-jian-zi-dong-ling-jing-dou-bot-hu-dong-zhi-ling/</id>
        <link href="https://yong-s.github.io/post/yun-fu-wu-qi-docker-da-jian-zi-dong-ling-jing-dou-bot-hu-dong-zhi-ling/">
        </link>
        <updated>2021-04-30T14:49:08.000Z</updated>
        <summary type="html"><![CDATA[<p>使用docker部署自动领金豆bot脚本</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用docker部署自动领金豆bot脚本</p>
<!-- more -->
<p>使用的版本：</p>
<p>服务器：centos 8</p>
<p>docker： 20.10.6</p>
<p>docker-compose： 1.27.4</p>
<h3 id="1-服务器安装dockerdocker-compose">1、服务器安装docker，docker-compose</h3>
<p>推荐使用centos服务器安装docker、docker-compose</p>
<p>Docker安装</p>
<ul>
<li>国内一键安装 <code>curl -sSL https://get.daocloud.io/docker | sh</code></li>
<li>国外一键安装 <code>curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</code></li>
</ul>
<p>docker-compose安装</p>
<p><code>$ sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</code></p>
<p>要安装其他版本的 Compose，请替换 1.24.1。</p>
<p>最新发行的版本地址：https://github.com/docker/compose/releases。</p>
<p>将可执行权限应用于二进制文件：</p>
<p><code>$ sudo chmod +x /usr/local/bin/docker-compose</code></p>
<p>创建软链：</p>
<p><code>$ sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</code></p>
<p>通过<code>docker-compose version</code>查看<code>docker-compose</code>版本，确认是否安装成功。</p>
<h3 id="2-安装jd_scripts">2、安装jd_scripts</h3>
<p>创建一个目录<code>jd_scripts</code>用于存放备份配置等数据，迁移重装的时候只需要备份整个jd_scripts目录即可</p>
<p>需要新建的目录文件结构参考如下:</p>
<pre><code>jd_scripts
├── logs
│   ├── XXXX.log
│   └── XXXX.log
├── my_crontab_list.sh
└── docker-compose.yml
</code></pre>
<ul>
<li><code>jd_scripts/logs</code>建一个空文件夹就行</li>
<li><code>jd_scripts/docker-compose.yml</code> 参考内容如下(自己动手能力不行搞不定请使用默认配置)：</li>
</ul>
<p>根据文档一步一步下去就ok了，下面主要记录下可能用到的命令</p>
<p>目录文件配置好之后在 <code>jd_scripts</code>目录执行。<br>
<code>docker-compose up -d</code> 启动（修改docker-compose.yml后需要使用此命令使更改生效）；<br>
<code>docker-compose logs</code> 打印日志；<br>
<code>docker-compose logs -f</code> 打印日志，-f表示跟随日志；<br>
<code>docker logs -f jd_scripts</code> 和上面两条相比可以显示汉字；<br>
<code>docker-compose pull</code> 更新镜像；<br>
<code>docker-compose stop</code> 停止容器；<br>
<code>docker-compose restart</code> 重启容器；<br>
<code>docker-compose down</code> 停止并删除容器；</p>
<h3 id="3-开代理机器激活tg-bot">3、开代理机器，激活tg-bot</h3>
<p>这里是个大坑，拿个小本本记下来，其实就是docker内代理宿主机代理的问题</p>
<p>由于众所周知的原因，国内的机器不能访问tg，而又想使用tg-bot来控制，无奈，国外机子太贵（穷），最低也要5美刀！遂买国内机子开代理使用</p>
<h5 id="1-买国内机器推荐大厂的">1、买国内机器，推荐大厂的</h5>
<p>这里应该放各大厂的aff的，留个坑</p>
<h5 id="2-安装clash">2、安装clash</h5>
<p>一直在使用clash，直接网上搜索clash<a href="https://github.com/Dreamacro/clash/releases">下载</a>，找到对应版本下载，博主用的是centos，下载linux-amd64的</p>
<p>1、下载clash，最新版本可去官网找</p>
<pre><code class="language-shell">wget https://github.com/Dreamacro/clash/releases/download/v0.19.0/clash-linux-amd64-v0.19.0.gz
</code></pre>
<p>2、解压</p>
<pre><code class="language-shell">gzip -d clash-linux-amd64-v0.19.0.gz
</code></pre>
<p>3、移动至usr/bin/clash并重命名为clash</p>
<pre><code class="language-shell">sudo mv clash-linux-amd64-v0.19.0 /usr/bin/clash
</code></pre>
<p>4、赋予clash运行权限</p>
<pre><code class="language-shell">sudo chmod +x /usr/bin/clash
</code></pre>
<p>5、检查是否安装成功</p>
<pre><code class="language-shell">clash -v 
</code></pre>
<h5 id="3-创建配置文件-安装控制面板">3、创建配置文件、安装控制面板</h5>
<p>1.创建配置文件目录</p>
<pre><code class="language-shell">mkdir -p /etc/clash/
</code></pre>
<p>2.进入目录</p>
<pre><code class="language-shell">cd /etc/clash/
</code></pre>
<p>3.创建配置文件</p>
<pre><code class="language-bash">vim config.yaml
</code></pre>
<p>4.手动编辑很麻烦，可用winscp上传</p>
<p>配置参数自行查找</p>
<p>5.下载前端代码</p>
<pre><code class="language-shell">wget https://github.com/Dreamacro/clash-dashboard/tree/gh-pages
</code></pre>
<p>6.解压</p>
<pre><code class="language-shell">unzip gh-pages.zip
</code></pre>
<p>7.修改目录名,这里的目录名是上面配置文件里的 external-ui: dashboard</p>
<pre><code class="language-shell">mv clash-dashboard-gh-pages dashboard
</code></pre>
<p><a href="http://clash.razord.top/">可用这个面板远程控制</a></p>
<h5 id="4-设置clash开机启动">4、设置clash开机启动</h5>
<p>1.创建service文件</p>
<pre><code class="language-shell">sudo vim /usr/lib/systemd/system/clash.service
</code></pre>
<p>2.输入下面代码</p>
<pre><code class="language-shell">[Unit]
Description=clash proxy
After=network.target

[Service]
Type=simple
ExecStart=/usr/bin/clash -d /etc/clash

[Install]
WantedBy=multi-user.target
</code></pre>
<p>3.重新加载 systemd 模块</p>
<pre><code class="language-shell">sudo systemctl daemon-reload
</code></pre>
<p>4.启动Clash</p>
<pre><code class="language-shell">sudo systemctl start clash.service
</code></pre>
<p>5.设置Clash开机自启动</p>
<pre><code class="language-shell">sudo systemctl enable clash.service
</code></pre>
<p>6.判断是否成功开启代理</p>
<pre><code class="language-shell">curl -I https://www.google.com
</code></pre>
<p>返回200即表示代理已经成功</p>
<h5 id="5-自动更新订阅配置文件">5、自动更新订阅配置文件</h5>
<blockquote>
<p>通过shell脚本自动更新Clash在线配置</p>
</blockquote>
<p>通过systemctl来管理Clash的进程，对应<code>clash.service</code>文件，通过两个脚本<code>start-clash.sh</code>和<code>stop-clash.sh</code>来管理Clash的启停：</p>
<p>把上面的配置文件修改下：</p>
<pre><code class="language-bash">vim/usr/lib/systemd/system/clash.service
</code></pre>
<pre><code class="language-shell">[Unit]
Description=clash proxy
After=network.target

[Service]
WorkingDirectory=/当前用户目录/.config/clash
Type=simple
ExecStart=/当前用户目录/.config/clash/start-clash.sh
ExecStop=/当前用户目录/.config/clash/stop-clash.sh
Environment=&quot;HOME=/当前用户目录&quot;
Environment=&quot;CLASH_URL=你的订阅链接&quot;

[Install]
WantedBy=multi-user.target

</code></pre>
<pre><code class="language-bash">vim /当前用户目录/.config/clash/start-clash.sh
</code></pre>
<pre><code class="language-bash">#!/bin/bash
# save this file to ${HOME}/.config/clash/start-clash.sh

# save pid file
echo $$ &gt; ${HOME}/.config/clash/clash.pid

diff ${HOME}/.config/clash/config.yaml &lt;(curl -s ${CLASH_URL})
if [ &quot;$?&quot; == 0 ]
then
    /usr/bin/clash
else
    TIME=`date '+%Y-%m-%d %H:%M:%S'`
    cp ${HOME}/.config/clash/config.yaml &quot;${HOME}/.config/clash/config.yaml.bak${TIME}&quot;
    curl -L -o ${HOME}/.config/clash/config.yaml ${CLASH_URL}
    /usr/bin/clash
fi
</code></pre>
<pre><code class="language-bash">vim /当前用户目录/.config/clash/stop-clash.sh
</code></pre>
<pre><code class="language-bash">#!/bin/bash
# save this file to ${HOME}/.config/clash/stop-clash.sh

# read pid file
PID=`cat ${HOME}/.config/clash/clash.pid`
kill -9 ${PID}
rm ${HOME}/.config/clash/clash.pid
</code></pre>
<p>配置添加完成后，如果你的clash 正在运行中，需要重新加载配置文件并重启</p>
<pre><code class="language-bash">$ systemctl daemon-reload
$ sudo systemctl restart clash.service
</code></pre>
<p>这样每次启动clash时就会自动更新配置文件了，接下来通过crontab 自动重启 clash.service实现自动更新节点</p>
<pre><code class="language-bash">#新建shell文件
vim restart-clash.sh
</code></pre>
<p>新增一条命令</p>
<pre><code class="language-bash">#/bin/sh
sudo systemctl restart clash.service

</code></pre>
<pre><code class="language-bash">chmod +x restart-clash.sh
crontab -e
#插入下面命令
#每3小时重启一次
0 */3 * * * restart-clash.sh
#每分钟重启一次
* * * * * restart-clash.sh
</code></pre>
<p>大功告成，可通过<code>tail -500f /var/log/cron</code>查看定时任务是否执行</p>
<p><code>sudo systemctl status clash.service</code>  查看是否重启成功</p>
<h3 id="4-docker内开代理">4、docker内开代理</h3>
<p>由于主要用来使用tg-bot，故只检测tgapi即可</p>
<p>1、判断宿主机可连接tgapi</p>
<pre><code class="language-shell">curl -sX POST &quot;https://api.telegram.org/bot'''Your Token'''/sendMessage&quot; -d &quot;chat_id=&quot;Some Chat id&quot;&amp;text=hello&quot;

curl -sX POST &quot;https://api.telegram.org/botxxxxxxxxugt5A/sendMessage&quot; -d &quot;chat_id=48xxxxxx&amp;text=hello&quot;
</code></pre>
<p>如果返回成功，即表示成功</p>
<p>2、进入容器</p>
<pre><code class="language-shell">docker exec -it jd_scripts /bin/sh
</code></pre>
<p>执行步骤1命令，如若响应时间长或失败，则需要配置代理</p>
<p>3、配置容器代理走宿主机</p>
<p><a href="https://docs.docker.com/network/proxy/#use-environment-variables">docker官方有教程</a></p>
<p>docker版本大于 17.07以上可用下面的方法</p>
<pre><code class="language-shell">cd
mkdir .docker
vim  ~/.docker/config.json

</code></pre>
<p>填入下面json</p>
<pre><code class="language-json">{
 &quot;proxies&quot;:
 {
   &quot;default&quot;:
   {
     &quot;httpProxy&quot;: &quot;http://172.17.0.1:7890&quot;,
     &quot;httpsProxy&quot;: &quot;http://172.17.0.1:7890&quot;,
     &quot;noProxy&quot;: &quot;localhost,127.0.0.1&quot;
&quot;
   }
 }
}
</code></pre>
<p>保存文件<strong>创建或者启动新容器时才生效</strong></p>
<p>这里有个大坑，搞了一天，就是</p>
<p><strong>代理的ip一定要写对！</strong></p>
<p><strong>代理的ip一定要写对！</strong></p>
<p><strong>代理的ip一定要写对!</strong></p>
<blockquote>
<p>下午调试的时候https的写成了127的了，机器启动起来，pull代码的时候，直接找不到文件，当时还骂这破代理，没法，就把报错ip不走代理了，没想到下面不报错了，直接无限重启，搞得头都大了，还在想是不是内存爆了呢！晚上，打开配置文件，定睛一看，WC！&quot;httpsProxy&quot;端口写的127...赶紧改了，重新跑遍，妥了，bot成功了！</p>
</blockquote>
<p>4、删除容器，重新启用</p>
<p>接下来在jd_scripts 目录内</p>
<pre><code class="language-shell">docker-compose down
docker-compose up -d
</code></pre>
<p>启动成功后，tgbot即可收到成功的消息，尽情享用吧！</p>
<h3 id="clash相关的管理命令">Clash相关的管理命令</h3>
<pre><code class="language-shell">## 启动Clash ##
sudo systemctl start clash.service

## 重启Clash ##
sudo systemctl restart clash.service

## 查看Clash运行状态 ##
sudo systemctl status clash.service

## 实时滚动状态 ##
sudo journalctl -u clash.service -f
</code></pre>
<h3 id="docker相关命令">docker相关命令</h3>
<p><code>docker exec -it jd_scripts /bin/sh -c 'git -C /scripts pull &amp;&amp; node /scripts/jd_bean_change.js'</code>  手动运行一脚本</p>
<p><code>docker exec -it jd_scripts /bin/sh -c 'env'</code>  查看设置的环境变量</p>
<p><code>docker exec -it jd_scripts /bin/sh -c 'crontab -l'</code>  查看已生效的crontab_list定时器任务</p>
<p><code>docker exec -it jd_scripts sh -c &quot;docker_entrypoint.sh&quot;</code> 手动更新jd_scripts仓库最新脚本</p>
<p><code>docker exec -it jd_scripts /bin/sh</code> 仅进入容器命令</p>
<p><code>rm -rf logs/*.log</code> 删除logs文件夹里面所有的日志文件</p>
<ul>
<li>[1] <a href="https://github.com/wisz2021/jd_docker">jd_docker</a></li>
<li>[2] <a href="https://github.com/yuanlam/Clash-Linux">clash安装参考</a></li>
<li>[3] <a href="https://kebingzao.com/2019/02/22/docker-container-proxy/">docker内代理参考</a></li>
<li>[4] <a href="https://akillcool.github.io/post/clash-with-auto-update-config/">clash自动更新订阅配置</a></li>
</ul>
]]></content>
    </entry>
</feed>