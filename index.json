[{"content":"config配置文件里加上如下参数：\nfrontmatter: lastmod: - lastmod - :git - :fileModTime - :default 依次取的顺序为：\n lastmod :最后提交时间\n:git: 根据git提交版本时间\n:fileModTime：文件修改时间\n Configure Hugo | Hugo 写的都有,but是英文的🙃\n","permalink":"https://blog.yongs.ml/posts/hugo-auto-update-lastmod/","summary":"config配置文件里加上如下参数： frontmatter: lastmod: - lastmod - :git - :fileModTime - :default 依次取的顺序为： lastmod :最后提交","title":"Hugo 自动更新文章修改时间"},{"content":"在linuxserver服务器上安装\n环境：docker、docker- compose\n需要了解docker基本知识，不懂可以翻翻以前的博客或者搜下教程学习\nfilebrowser官网上给的是docker命令执行的，但用compose习惯了，所以转换了一下格式，但是这里有个坑，官网也提示了\n By default, we already have a configuration file with some defaults so you can just mount the root and the database. Although you can overwrite by mounting a directory with a new config file. If you don\u0026rsquo;t already have a database file, make sure to create a new empty file under the path you specified. Otherwise, Docker will create an empty folder instead of an empty file, resulting in an error when mounting the database into the container.\n 翻译过来就是需要提前创建所需的文件和文件夹，否则，Docker会创建一个空的文件夹而不是空的文件，导致在将数据库挂载到容器中时出现错误！这点一定要注意啊！！！\n1、创建docker-compose文件 内容如下：\nversion: \u0026#39;3.3\u0026#39; services: filebrowser: image: filebrowser/filebrowser:s6 container_name: filebrowser volumes: - ./root:/srv - ./database/filebrowser.db:/database/filebrowser.db - ./settings.json:/config/settings.json environment: - PUID=0 - PGID=0 ports: - \u0026#39;8080:80\u0026#39; restart: always 2、创建默认文件和文件夹 对照上述docker-compose的路径，需要在当前目录创建 settings.json 文件，内容如下：\n{ \u0026#34;port\u0026#34;: 80, \u0026#34;baseURL\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;log\u0026#34;: \u0026#34;stdout\u0026#34;, \u0026#34;database\u0026#34;: \u0026#34;/database/filebrowser.db\u0026#34;, \u0026#34;root\u0026#34;: \u0026#34;/srv\u0026#34; } 在当前目录创建 database/filebrowser.db 文件夹和文件\nmkdir database cd database touch filebrowser.db 3、运行测试是否成功 执行 docker- compose logs -f 看下日志是否报错\n需要其他机器访问记得防火墙 把端口打开，本例用的8080端口\n浏览器访问 服务器ip:8080 成功打开即可，Enjoy it！🎉🎉🎉\n 参考：\n1、filebrowser官网\n2、filebrowser 一个跨平台的文件管理器的使用方法-森林的个人博客\n ","permalink":"https://blog.yongs.ml/posts/docker-deploy-filebrowser/","summary":"在linuxserver服务器上安装 环境：docker、docker- compose 需要了解do","title":"Docker Compose部署filebrowser"},{"content":" 欢迎来到我的小站呀，很高兴遇见你！🤝\n 🏠 关于本站 这里主要记录一些平常遇到的一些技术坑，方便以后可以查阅😄\n本站最开始是2019年就搭建了，当时用的hexo构建，部署在github，用netlify缓存服务，无奈当时穷，用的还是Windows本，用命令太不爽了，导致写文章没什么激情，基本断更🤣\n来到2021年，经常在网上看大佬们的blog，时间有点空，就想把blog给拾起来，接触的技术也多了，也想记录下一些笔记，方便后面随时翻阅，正好在推上看到大佬们推荐gridea: ✍️ A static blog writing client (一个静态博客写作客户端)\n傻瓜式操作，根据界面提示设置就行了，专注于写作，当时就下下来用了一段时间，也有比较鸡肋的地方，比如主题太少，自定义空间太小，还有就是windows7上不太稳定，有时会卡，可能我电脑垃圾吧，主题太少，有的主题不支持侧边目录栏，当时搜了好多文章，才改了一下主题，具体看这篇，还有就是，作者好久不更新了，专注于搞web端了，所以就在换了Mac后就换了到hugo上\nhugo用go开发的，据说生成文章非常快，相比hexo来说，hugo在Mac上用命令也很舒服，主题也很多，所以就果断换了上来，专注写作，主题用的papermod，这是国外开发者开发的，中文资料太少，不过，搜了好多大佬的文章，基本上调试ok；还是用github做仓库来提供服务，用markdown来写文章，vs code来配置文件，在freenom上白嫖的一年域名，用脚本自动监控，到期提示；用cf来做域名解析和缓存服务。\n👨‍💻 博主是谁 匆匆的蚂蚁 克莱登大学毕业 没有理想的人不伤心 某非知名小厂规则长方体固体物质空间移动工程师\n","permalink":"https://blog.yongs.ml/about/","summary":"欢迎来到我的小站呀，很高兴遇见你！🤝 🏠 关于本站 这里主要记录一些平常遇到的一些技术坑，","title":"About"},{"content":"看过前面的文章知道，大佬的库仓库也锁了，不能pull，只能换取仓库地址才行，为了一劳永逸，索性换了自己的库，只谈技术，不谈其他\u0026hellip;\n1、创建Dockerfile文件 比较懒，直接把大佬的Dockerfile拉来换了仓库地址，rsa记着也要换\n换完在当前目录 docker build -t jd_scripts .\n直接生成自己的image\ndocker images 查看镜像\n2、修改docker-compose文件 修改docker-compose里面的仓库地址为自己的地址，其他参数不用变\ndocker-compose up -d 启动镜像\n完美运行！\n继续躺平。\n建议学学docker，真的好强大！\n附上一个不错的docker教程\nDocker —— 从入门到实践\n","permalink":"https://blog.yongs.ml/posts/docker-generate-image/","summary":"看过前面的文章知道，大佬的库仓库也锁了，不能pull，只能换取仓库地址才行，为了一劳","title":"docker 生成自己的镜像"},{"content":"修改主题文件支持侧边栏目录\nsimple主题整体还行，但文章无侧边栏目录，一般写的技术性文章很长，就需要侧边栏目录和这个功能了，在网上搜了一下资料，对于前端小学生的我费了好长时间才搞定，记录一下过程。\n1、修改post.ejs文件 head新增\n\u0026lt;script src=\u0026quot;https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\n搜索\u0026lt;%- post.content %\u0026gt;复制一下代码覆盖copy\n\u0026lt;div class=\u0026#34;post-content-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;post-content\u0026#34; v-pre\u0026gt; \u0026lt;%- post.content %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;toc-container\u0026#34;\u0026gt; \u0026lt;%- post.toc %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 新增高亮js\n\u0026lt;script\u0026gt; hljs.initHighlightingOnLoad() let mainNavLinks = document.querySelectorAll(\u0026#34;.markdownIt-TOC a\u0026#34;); // This should probably be throttled.  // Especially because it triggers during smooth scrolling.  // https://lodash.com/docs/4.17.10#throttle  // You could do like...  // window.addEventListener(\u0026#34;scroll\u0026#34;, () =\u0026gt; {  // _.throttle(doThatStuff, 100);  // });  // Only not doing it here to keep this Pen dependency-free.  window.addEventListener(\u0026#34;scroll\u0026#34;, event =\u0026gt; { let fromTop = window.scrollY; mainNavLinks.forEach((link, index) =\u0026gt; { let section = document.getElementById(decodeURI(link.hash).substring(1)); let nextSection = null if (mainNavLinks[index + 1]) { nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1)); } if (section.offsetTop \u0026lt;= fromTop) { if (nextSection) { if (nextSection.offsetTop \u0026gt; fromTop) { link.classList.add(\u0026#34;current\u0026#34;); } else { link.classList.remove(\u0026#34;current\u0026#34;); } } else { link.classList.add(\u0026#34;current\u0026#34;); } } else { link.classList.remove(\u0026#34;current\u0026#34;); } }); }); \u0026lt;/script\u0026gt; 2、客户端新增自定义css .toc-container .markdownIt-TOC { position: sticky; top: 32px; width: 200px; font-size: 12px; list-style: none; padding-left: 0; padding: 16px 8px; } .toc-container .markdownIt-TOC:before { content: \u0026#34;\u0026#34;; position: absolute; top: 0; left: 8px; bottom: 0; width: 1px; background-color: #ebedef; opacity: .5; } .toc-container ul { list-style: none; } .toc-container li { padding-left: 16px; } .toc-container li a { color: #868e96; padding: 4px; display: block; transition: all 0.3s; } .toc-container li a:hover { background: #cddbef; } .toc-container li a.current { color: #006CFF; background: #fafafa; } .post-content-wrapper { display: flex; } .post-content { width: 100%; margin-right: 20px; } @media (max-width: 1150px) { .toc-container { display: none; } } 3、修改main.css文件 搜索.post-detail 修改margin: 0 auto;为\nmargin: 0 20px;\n重新渲染网页即可尽情享用吧！\n","permalink":"https://blog.yongs.ml/posts/girde-simple-support-for-sidebar-directory/","summary":"修改主题文件支持侧边栏目录 simple主题整体还行，但文章无侧边栏目录，一般写的技术","title":"girde simple修改添加支持侧边栏目录"},{"content":"使用docker部署自动领金豆bot脚本\n使用的版本：\n服务器：centos 8\ndocker： 20.10.6\ndocker-compose： 1.27.4\n1、服务器安装docker，docker-compose 推荐使用centos服务器安装docker、docker-compose\nDocker安装\n 国内一键安装 curl -sSL https://get.daocloud.io/docker | sh 国外一键安装 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun  docker-compose安装\n$ sudo curl -L \u0026quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)\u0026quot; -o /usr/local/bin/docker-compose\n要安装其他版本的 Compose，请替换 1.24.1。\n最新发行的版本地址：https://github.com/docker/compose/releases。\n将可执行权限应用于二进制文件：\n$ sudo chmod +x /usr/local/bin/docker-compose\n创建软链：\n$ sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose\n通过docker-compose version查看docker-compose版本，确认是否安装成功。\n2、安装jd_scripts 创建一个目录jd_scripts用于存放备份配置等数据，迁移重装的时候只需要备份整个jd_scripts目录即可\n需要新建的目录文件结构参考如下:\njd_scripts ├── logs │ ├── XXXX.log │ └── XXXX.log ├── my_crontab_list.sh └── docker-compose.yml  jd_scripts/logs建一个空文件夹就行 jd_scripts/docker-compose.yml 参考内容如下(自己动手能力不行搞不定请使用默认配置)：  根据文档一步一步下去就ok了，下面主要记录下可能用到的命令\n目录文件配置好之后在 jd_scripts目录执行。\ndocker-compose up -d 启动（修改docker-compose.yml后需要使用此命令使更改生效）；\ndocker-compose logs 打印日志；\ndocker-compose logs -f 打印日志，-f表示跟随日志； docker logs -f jd_scripts 和上面两条相比可以显示汉字； docker-compose pull 更新镜像；\ndocker-compose stop 停止容器；\ndocker-compose restart 重启容器；\ndocker-compose down 停止并删除容器；\n3、开代理机器，激活tg-bot 这里是个大坑，拿个小本本记下来，其实就是docker内代理宿主机代理的问题\n由于众所周知的原因，国内的机器不能访问tg，而又想使用tg-bot来控制，无奈，国外机子太贵（穷），最低也要5美刀！遂买国内机子开代理使用\n1、买国内机器，推荐大厂的 这里应该放各大厂的aff的，留个坑\n2、安装clash 一直在使用clash，直接网上搜索clash下载，找到对应版本下载，博主用的是centos，下载linux-amd64的\n1、下载clash，最新版本可去官网找\nwget https://github.com/Dreamacro/clash/releases/download/v0.19.0/clash-linux-amd64-v0.19.0.gz 2、解压\ngzip -d clash-linux-amd64-v0.19.0.gz 3、移动至usr/bin/clash并重命名为clash\nsudo mv clash-linux-amd64-v0.19.0 /usr/bin/clash 4、赋予clash运行权限\nsudo chmod +x /usr/bin/clash 5、检查是否安装成功\nclash -v 3、创建配置文件、安装控制面板 1.创建配置文件目录\nmkdir -p /etc/clash/ 2.进入目录\ncd /etc/clash/ 3.创建配置文件\nvim config.yaml 4.手动编辑很麻烦，可用winscp上传\n配置参数自行查找\n5.下载前端代码\nwget https://github.com/Dreamacro/clash-dashboard/tree/gh-pages 6.解压\nunzip gh-pages.zip 7.修改目录名,这里的目录名是上面配置文件里的 external-ui: dashboard\nmv clash-dashboard-gh-pages dashboard 可用这个面板远程控制\n4、设置clash开机启动 1.创建service文件\nsudo vim /usr/lib/systemd/system/clash.service 2.输入下面代码\n[Unit] Description=clash proxy After=network.target [Service] Type=simple ExecStart=/usr/bin/clash -d /etc/clash [Install] WantedBy=multi-user.target 3.重新加载 systemd 模块\nsudo systemctl daemon-reload 4.启动Clash\nsudo systemctl start clash.service 5.设置Clash开机自启动\nsudo systemctl enable clash.service 6.判断是否成功开启代理\ncurl -I https://www.google.com 返回200即表示代理已经成功\n5、自动更新订阅配置文件  通过shell脚本自动更新Clash在线配置\n 通过systemctl来管理Clash的进程，对应clash.service文件，通过两个脚本start-clash.sh和stop-clash.sh来管理Clash的启停：\n把上面的配置文件修改下：\nvim /usr/lib/systemd/system/clash.service [Unit] Description=clash proxy After=network.target [Service] WorkingDirectory=/当前用户目录/.config/clash Type=simple ExecStart=/当前用户目录/.config/clash/start-clash.sh ExecStop=/当前用户目录/.config/clash/stop-clash.sh Environment=\u0026#34;HOME=/当前用户目录\u0026#34; Environment=\u0026#34;CLASH_URL=你的订阅链接\u0026#34; [Install] WantedBy=multi-user.target vim /当前用户目录/.config/clash/start-clash.sh #!/bin/bash # save this file to ${HOME}/.config/clash/start-clash.sh # save pid file echo $$ \u0026gt; ${HOME}/.config/clash/clash.pid diff ${HOME}/.config/clash/config.yaml \u0026lt;(curl -s ${CLASH_URL}) if [ \u0026#34;$?\u0026#34; == 0 ] then /usr/bin/clash else TIME=`date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;` cp ${HOME}/.config/clash/config.yaml \u0026#34;${HOME}/.config/clash/config.yaml.bak${TIME}\u0026#34; curl -L -o ${HOME}/.config/clash/config.yaml ${CLASH_URL} /usr/bin/clash fi vim /当前用户目录/.config/clash/stop-clash.sh #!/bin/bash # save this file to ${HOME}/.config/clash/stop-clash.sh # read pid file PID=`cat ${HOME}/.config/clash/clash.pid` kill -9 ${PID} rm ${HOME}/.config/clash/clash.pid 配置添加完成后，如果你的clash 正在运行中，需要重新加载配置文件并重启\n$ systemctl daemon-reload $ sudo systemctl restart clash.service 这样每次启动clash时就会自动更新配置文件了，接下来通过crontab 自动重启 clash.service实现自动更新节点\n#新建shell文件 vim restart-clash.sh 新增一条命令\n#/bin/sh sudo systemctl restart clash.service chmod +x restart-clash.sh crontab -e #插入下面命令 #每3小时重启一次 0 */3 * * * restart-clash.sh #每分钟重启一次 * * * * * restart-clash.sh 大功告成，可通过tail -500f /var/log/cron查看定时任务是否执行\nsudo systemctl status clash.service 查看是否重启成功\n4、docker内开代理 由于主要用来使用tg-bot，故只检测tgapi即可\n1、判断宿主机可连接tgapi\ncurl -sX POST \u0026#34;https://api.telegram.org/bot\u0026#39;\u0026#39;\u0026#39;Your Token\u0026#39;\u0026#39;\u0026#39;/sendMessage\u0026#34; -d \u0026#34;chat_id=\u0026#34;Some Chat id\u0026#34;\u0026amp;text=hello\u0026#34; curl -sX POST \u0026#34;https://api.telegram.org/botxxxxxxxxugt5A/sendMessage\u0026#34; -d \u0026#34;chat_id=48xxxxxx\u0026amp;text=hello\u0026#34; 如果返回成功，即表示成功\n2、进入容器\ndocker exec -it jd_scripts /bin/sh 执行步骤1命令，如若响应时间长或失败，则需要配置代理\n3、配置容器代理走宿主机\ndocker官方有教程\ndocker版本大于 17.07以上可用下面的方法\ncd mkdir .docker vim ~/.docker/config.json 填入下面json\n{ \u0026#34;proxies\u0026#34;: { \u0026#34;default\u0026#34;: { \u0026#34;httpProxy\u0026#34;: \u0026#34;http://172.17.0.1:7890\u0026#34;, \u0026#34;httpsProxy\u0026#34;: \u0026#34;http://172.17.0.1:7890\u0026#34;, \u0026#34;noProxy\u0026#34;: \u0026#34;localhost,127.0.0.1\u0026#34; \u0026#34; } } } 保存文件创建或者启动新容器时才生效\n这里有个大坑，搞了一天，就是\n代理的ip一定要写对！\n代理的ip一定要写对！\n代理的ip一定要写对!\n 下午调试的时候https的写成了127的了，机器启动起来，pull代码的时候，直接找不到文件，当时还骂这破代理，没法，就把报错ip不走代理了，没想到下面不报错了，直接无限重启，搞得头都大了，还在想是不是内存爆了呢！晚上，打开配置文件，定睛一看，WC！\u0026ldquo;httpsProxy\u0026quot;端口写的127\u0026hellip;赶紧改了，重新跑遍，妥了，bot成功了！\n 4、删除容器，重新启用\n接下来在jd_scripts 目录内\ndocker-compose down docker-compose up -d 启动成功后，tgbot即可收到成功的消息，尽情享用吧！\nClash相关的管理命令 ## 启动Clash ## sudo systemctl start clash.service ## 重启Clash ## sudo systemctl restart clash.service ## 查看Clash运行状态 ## sudo systemctl status clash.service ## 实时滚动状态 ## sudo journalctl -u clash.service -f docker相关命令 docker exec -it jd_scripts /bin/sh -c 'git -C /scripts pull \u0026amp;\u0026amp; node /scripts/jd_bean_change.js' 手动运行一脚本\ndocker exec -it jd_scripts /bin/sh -c 'env' 查看设置的环境变量\ndocker exec -it jd_scripts /bin/sh -c 'crontab -l' 查看已生效的crontab_list定时器任务\ndocker exec -it jd_scripts sh -c \u0026quot;docker_entrypoint.sh\u0026quot; 手动更新jd_scripts仓库最新脚本\ndocker exec -it jd_scripts /bin/sh 仅进入容器命令\nrm -rf logs/*.log 删除logs文件夹里面所有的日志文件\n [1] jd_docker [2] clash安装参考 [3] docker内代理参考 [4] clash自动更新订阅配置  ","permalink":"https://blog.yongs.ml/posts/docker-build-jdbot/","summary":"使用docker部署自动领金豆bot脚本 使用的版本： 服务器：centos 8 docke","title":"云服务器docker搭建自动领京豆bot互动指令"}]